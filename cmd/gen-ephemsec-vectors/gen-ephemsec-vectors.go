package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"os"
	"strings"

	"code.kerpass.org/golang/pkg/algos"
	"code.kerpass.org/golang/pkg/ephemsec"
)

const usageFmt = `
Command Usage: %s [Flags]
  Generate KerPass EPHEMSEC test vectors.

Flags:
------
`

var defaultSchemes []string

type Cmd struct {
	Out     *json.Encoder
	Schemes []string
	Repeat  int
}

func parseFlags(progname string, args []string) *Cmd {
	cmd := Cmd{}

	flags := flag.NewFlagSet(progname, flag.ExitOnError)
	flags.Usage = func() {
		fmt.Fprintf(os.Stderr, usageFmt, progname)
		flags.PrintDefaults()
	}

	var outPath string
	flags.StringVar(&outPath, "out", "-", `path where to save the generated vectors`)

	var schemes []string
	const schemeDoc = `
	Valid EPHEMSEC scheme.
	Add more than 1 by repeating this option.
	Default to a long autogenerated list that uses all registered algorithms.
	`
	flags.Func("scheme", oneline(schemeDoc), func(v string) error {
		_, err := ephemsec.NewScheme(v)
		if nil == err {
			schemes = append(schemes, v)
		}
		return err
	})

	var repeat uint
	flags.UintVar(&repeat, "repeat", 10, `number of vectors to generate for each scheme`)

	flags.Parse(args)

	// set cmd.Out
	var err error
	var outFile *os.File
	if "-" != outPath {
		outFile, err = os.OpenFile(outPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
		if nil != err {
			log.Fatalf("Failed opening %s, got error %v", outPath, err)
		}
	} else {
		outFile = os.Stdout
	}
	enc := json.NewEncoder(outFile)
	enc.SetIndent("", "  ")
	cmd.Out = enc

	// set cmd.Schemes
	if len(schemes) > 0 {
		cmd.Schemes = schemes
	} else {
		cmd.Schemes = defaultSchemes
	}

	// set cmd.Repeat
	cmd.Repeat = int(repeat)

	return &cmd
}

func main() {
	cmd := parseFlags(os.Args[0], os.Args[1:])

	var err error
	var vectors []ephemsec.TestVector
	for _, schemename := range cmd.Schemes {
		for _ = range cmd.Repeat {
			vector := ephemsec.TestVector{}
			err = fillVector(schemename, &vector)
			if nil != err {
				log.Fatalf("Failed generating TestVector, got error %v", err)
			}
			vectors = append(vectors, vector)
		}
	}
	err = cmd.Out.Encode(vectors)
	if nil != err {
		log.Fatalf("Failed serializing []TestVector, got error %v", err)
	}
}

func oneline(multilines string) string {
	var sb strings.Builder
	var hasline bool
	for line := range strings.Lines(multilines) {
		if hasline {
			sb.WriteString(" ")
		}
		sb.WriteString(strings.TrimSpace(line))
		hasline = true
	}
	return sb.String()
}

func init() {
	hashes := algos.ListHashes()
	curves := algos.ListCurves()
	keyexs := []string{"E1S1", "E1S2", "E2S2"}
	passes := []string{"T400_B10_P7", "T500_B16_P8", "T600_B32_P8", "T550_B256_P32", "T1024_B256_P64"}
	for _, hash := range hashes {
		for _, curve := range curves {
			for _, keyex := range keyexs {
				for _, pass := range passes {
					defaultSchemes = append(
						defaultSchemes,
						fmt.Sprintf("Kerpass_%s_%s_%s_%s", hash, curve, keyex, pass),
					)
				}
			}
		}
	}
}
