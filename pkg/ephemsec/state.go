package ephemsec

import (
	"crypto/ecdh"
	"encoding/binary"
	"time"
)

var (
	allZeros [maxZero]byte
)

type State struct {

	// Context is application defined
	Context []byte

	// Nonce is generated by the initiator
	Nonce []byte

	// Unix timestamp
	// if zero, system Unix time is used
	Time int64

	// SynchroHint is generated by the responder
	SynchroHint int

	// Message is optional
	// An OTP/OTK can be generated to show that the message was reviewed/accepted
	Message []byte

	// local ephemeral key
	EphemKey *ecdh.PrivateKey

	// local static key
	StaticKey *ecdh.PrivateKey

	// remote ephemeral key
	RemoteEphemKey *ecdh.PublicKey

	// remote static key
	RemoteStaticKey *ecdh.PublicKey

	// psk credential
	Psk []byte

	// ikm provides storage for 2 DH shared secrets and 1 PSK
	// maximum DH shared secret size is assumed to be 66 bytes (P-521 case)
	// ikm is used as 'secret' input for HKDF output derivation
	ikm [maxIKM]byte

	// ikmcursor contains the length of the ikm data
	ikmcursor int

	// context provides storage for domain separation context
	// context is used as 'salt' input for HKDF output derivation
	context [maxContext + maxSchemeName + 16]byte

	// contextcursor contains the length of the context data
	contextcursor int

	// info provides storage for initiator nonce, 8 bytes timestamp and optional message
	// info is used as 'info' input for HKDF output derivation
	info [maxInfo]byte

	// ptime stores the info timestamp
	ptime int64

	// infocursor contains the length of the info data
	infocursor int

	// output provides storage for HKDF output
	output [otkMaxBytes]byte

	// outputcursor contains the length of the output data
	outputcursor int
}

// Reset prepares the State for reuse.
func (self *State) Reset() {

	self.EphemKey = nil
	self.StaticKey = nil
	self.RemoteEphemKey = nil
	self.RemoteStaticKey = nil
	self.Psk = nil
	self.Nonce = nil
	self.SynchroHint = missing
	self.Message = nil

	zeros := allZeros[:]

	self.contextcursor = 0

	ikm := self.ikm[:]
	copy(ikm, zeros)
	self.ikmcursor = 0

	output := self.output[:]
	copy(output, zeros)
	self.outputcursor = 0

	info := self.info[:]
	copy(info, zeros)
	self.ptime = 0
	self.infocursor = 0
}

// setContext concatenates Context & scheme Name and saves resulting byte string into the State.
// the resulting byte string will be used as 'salt' for HKDF domain separation.
func (self *State) setContext(sch scheme) error {
	context := self.context[:0]

	// add state Context
	if len(self.Context) > maxContext {
		return newError("Context length larger that %d", maxContext)
	}
	context = append(context, markContext)
	context = append(context, byte(len(self.Context))) // fit on 1 byte due to maxContext limit
	context = append(context, self.Context...)

	// add scheme Name
	context = append(context, markSchemeName)
	context = append(context, byte(len(sch.N))) // fit on 1 byte due to maxSchemeName limit
	context = append(context, []byte(sch.N)...)

	csz := len(context)
	if csz > maxContextBuffer {
		return newError("context buffer overflow")
	}
	self.contextcursor = csz

	return nil
}

// setPtime save PTIME into the state
// It derives PTIME from the Time parameter or system Unix time
func (self *State) setPTime(sch scheme, role role) error {
	ts := self.Time
	if 0 == ts {
		ts = time.Now().Unix()
	}
	switch role {
	case Initiator:
		if missing == self.SynchroHint {
			return newError("missing SynchroHint parameter value")
		}
		pt, err := sch.SyncTime(ts, self.SynchroHint)
		if nil != err {
			return wrapError(err, "failed SyncTime")
		}
		self.ptime = pt
	case Responder:
		pt, sh := sch.Time(ts)
		self.ptime = pt
		self.SynchroHint = sh
	}
	return nil
}

// setInfo concatenates Nonce and PTIME and saves the resulting byte string into the State
// the resulting byte string will be used as 'info' for HKDF key personalization.
func (self *State) setInfo() error {
	info := self.info[:0]

	// add state Nonce
	nsz := len(self.Nonce)
	if nsz < minNonce || nsz > maxNonce {
		return newError("Nonce length %d not in %d..%d range", nsz, minNonce, maxNonce)
	}
	info = append(info, markNonce)
	info = append(info, byte(nsz))
	info = append(info, self.Nonce...)

	// add state ptime
	info = append(info, markPTime)
	info = append(info, 8) // size of int64
	info = binary.BigEndian.AppendUint64(info, uint64(self.ptime))

	isz := len(info)
	if isz > maxInfo {
		return newError("info buffer overflow")
	}
	self.infocursor = isz

	return nil
}
